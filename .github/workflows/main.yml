# This is a basic workflow to help you get started with Actions

name: Publish package

# Controls when the action will run. 
# Triggers the workflow on push or pull request events
on: 
  push:

  # Allows you to run this workflow manually from the Actions tab
  workflow_dispatch:

# A workflow run is made up of one or more jobs that can run sequentially or in parallel
jobs:
  # This workflow contains a single job called "build"
  build:
    # The type of runner that the job will run on
    runs-on: windows-latest

    # Steps represent a sequence of tasks that will be executed as part of the job
    steps:
      # Checks-out your repository under $GITHUB_WORKSPACE, so your job can access it
      - uses: actions/checkout@v2
      
      - name: Build and publish package
        run: |
          $root = Get-Location

          @("Yourkeys.Models.Leads","Yourkeys.Dal.LeadsDb") | ForEach-Object {
            $projDir = "Yourkeys.Models.Leads/$_"
            $proj = "$projDir/$_.csproj"
            $releaseDir = "bin/Release"
            $vsnPattern = "<Version>(?<version>[\d+]\.[\d+]\.[\d+])</Version>"

            $projFile = Get-Content -Path $proj
            $result = [regex]::Matches($projFile, $vsnPattern)
            $vsn = $result[0].Groups['version'].Value
            
            # if not the main branch then use a valid semver pre-release format with branch name with special chars removed, lower cased 
            # and truncated to 10 chars, and datetime, e.g. 'refs/heads/feature/YK-1234_a-branch' becomes 1.0.0-yk1234_abr.yyyyMMddHHmmss
            if ("${{ github.ref }}" -ne "refs/heads/main") {
                $now = [System.DateTime]::Now.ToString("yyyyMMddHHmmss")

                $parts = "${{ github.ref }}".Split('/')

                $branch = ($parts[$parts.Length - 1] -replace '[^a-zA-Z0-9]', '').ToLower()

                if ($branch.Length -gt 10) {
                $branch = $branch.Substring(0, 10)
                }

                $preReleaseVsn = "$vsn-$branch.$now"
                            
                Set-Content -Path $proj -Value ($projFile -Replace $vsn, $preReleaseVsn)
                
                $vsn = $preReleaseVsn
            }

            Set-Location "Yourkeys.Models.Leads/$_"
          
            # build the project. no need to pack as the project is configured to create a package on build.
            dotnet build --configuration Release
            
            $loc = Get-Location
            
            dotnet nuget push "$loc/bin/Release/$($_).$($vsn).nupkg" --source "Yourkeys-github"

            Set-Location $root
          }
        shell: pwsh

      - name: Clean old packages
        run: |
          $id = get-random
          $code =  @"
          using System;
          using System.Linq;
          using System.Net.Http;
          using System.Net.Http.Headers;
          using System.Text;
          using System.Text.Json;
          using System.Text.Json.Serialization;
          using System.Text.RegularExpressions;

          namespace ExpiredPackagesLib
          {
              public static class ExpiredPackages$id
              {
                  public static HttpClient client;
        
                  public static void Clean()
                  {
                      try
                      {
                          // use GraphQL API to get package ids
                          client = GetClient();
                          
                          var q = new
                          {
                              query = "query {repository(owner:\"Yourkeys\", name:\"yourkeys-models-leads\") {packages(last:50) {edges{node{id, name, versions(last:20){edges {node {id, version, files(last:10){edges {node {updatedAt}}}}}}}}}}}"
                          };

                          using var response = client.SendAsync(new HttpRequestMessage
                          {
                              Method = HttpMethod.Post,
                              Content = new StringContent(JsonSerializer.Serialize(q), Encoding.UTF8, "application/json")
                          }).Result;
                          
                          response.EnsureSuccessStatusCode();

                          GraphQlResponse$id j = JsonSerializer.Deserialize<GraphQlResponse$id>(response.Content.ReadAsStringAsync().Result);

                          // find packages to delete
                          (from packagesEdge in j.Data.Repository.Packages.Edges
                                  from versionEdge in packagesEdge.Node.Versions.Edges
                                  where !Regex.IsMatch(versionEdge.Node.Version, @"^[\d]+\.[\d]+\.[\d]+$")
                                  where DateTime.Now.Subtract(versionEdge.Node.Files.Edges.FirstOrDefault()?.Node?.UpdatedAt ?? DateTime.Now).Days > 30
                                  select versionEdge.Node.Id)
                              .ToList()
                              .ForEach(packageId =>
                              {
                                  // delete package
                                  client = GetClient();

                                  q = new
                                  {
                                      query = $"mutation {{ deletePackageVersion(input:{{packageVersionId:\"{packageId}\"}}) {{ success }}}}"
                                  };

                                  using var r = client.SendAsync(new HttpRequestMessage
                                  {
                                      Method = HttpMethod.Post,
                                      Content = new StringContent(JsonSerializer.Serialize(q), Encoding.UTF8, "application/json")
                                  }).Result;

                                  r.EnsureSuccessStatusCode();
                              });
                      }
                      catch (Exception)
                      {
                          
                      }
                  }

                  private static HttpClient GetClient()
                  {
                      client = new HttpClient { BaseAddress = new Uri("https://api.github.com/graphql") };

                      client.DefaultRequestHeaders.Accept.Clear();
                      client.DefaultRequestHeaders.Accept.Add(new MediaTypeWithQualityHeaderValue("application/vnd.github.package-deletes-preview+json"));
                      client.DefaultRequestHeaders.Add("User-Agent", "MyConsoleApp");

                      var basicAuth = Convert.ToBase64String(Encoding.UTF8.GetBytes("Yourkeys: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"));

                      client.DefaultRequestHeaders.Authorization = new AuthenticationHeaderValue("Basic", basicAuth);

                      return client;
                  }
              }

              public class GraphQlResponse$id
              {
                  [JsonPropertyName("data")]
                  public Data$id Data { get; set; }
              }

              public class Data$id
              {
                  [JsonPropertyName("repository")]
                  public Repository$id Repository { get; set; }
              }

              public class Repository$id
              {
                  [JsonPropertyName("packages")]
                  public Packages$id Packages { get; set; }
              }

              public class Packages$id
              {
                  [JsonPropertyName("edges")]
                  public Edge$id[] Edges { get; set; }
              }

              public class Edge$id
              {
                  [JsonPropertyName("node")]
                  public Node$id Node { get; set; }
              }

              public class Node$id
              {
                  [JsonPropertyName("id")]
                  public string Id { get; set; }

                  [JsonPropertyName("name")]
                  public string Name { get; set; }

                  [JsonPropertyName("versions")]
                  public Versions$id Versions { get; set; }
              }

              public class Versions$id
              {
                  [JsonPropertyName("edges")]
                  public VersionEdge$id[] Edges { get; set; }
              }

              public class VersionEdge$id
              {
                  [JsonPropertyName("node")]
                  public VersionNode$id Node { get; set; }
              }

              public class VersionNode$id
              {
                  [JsonPropertyName("id")]
                  public string Id { get; set; }

                  [JsonPropertyName("version")]
                  public string Version { get; set; }

                  [JsonPropertyName("files")]
                  public Files$id Files { get; set; }
              }

              public class Files$id
              {
                  [JsonPropertyName("edges")]
                  public FileEdge$id[] Edges { get; set; }
              }

              public class FileEdge$id
              {
                  [JsonPropertyName("node")]
                  public FileNode$id Node { get; set; }
              }

              public class FileNode$id
              {
                  [JsonPropertyName("updatedAt")]
                  public DateTime UpdatedAt { get; set; }
              }

          }
          "@

          Add-Type -TypeDefinition $code -Language CSharp 
          Invoke-Expression "[ExpiredPackagesLib.ExpiredPackages$id]::Clean()"
        shell: pwsh
